{"version":3,"sources":["Redux/SearchField/SearchField.actions.ts","Redux/SearchField/SearchField.types.ts","Components/SearchField/SearchField.tsx","Components/Kittens/Kittens.tsx","Components/KittensList/KittensList.tsx","Redux/Kittens/Kittens.actions.ts","Redux/Kittens/Kittens.types.ts","Containers/App.tsx","serviceWorker.js","Redux/Kittens/Kitten.reducers.ts","Redux/SearchField/SearchField.reducer.ts","Redux/rootReducer.js","Redux/store.ts","index.tsx"],"names":["searchChange","event","type","payload","connect","dispatch","bindActionCreators","Fragment","className","placeholder","onChange","Kittens","name","id","email","phone","website","src","alt","state","kittensArray","kittensList","inputValue","searchInput","filter","kitten","toLowerCase","includes","toLocaleLowerCase","map","key","requestKittens","getState","fetch","then","response","json","data","requestKittensSuccess","catch","error","requestKittensFailed","App","this","props","React","Component","Boolean","window","location","hostname","match","initialState","isPending","combineReducers","action","target","value","middlewares","thunk","store","createStore","rootReducer","applyMiddleware","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","registration","unregister","console","message"],"mappings":"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","file":"static/js/main.6a99f8d7.chunk.js","sourcesContent":["import { SEARCHFIELD_CHANGE, searchFieldActions } from \"./SearchField.types\";\n\n// TypeScript infers that this function is returning SearchChangeAction.\n// in here we need to do two things  one is the type of the parameter\n// and the  second one is to specify return type for each one of these actions\n//(in our case it is the searcnBoxActionTypes ie SEARCHFIELD_CHANGE)\n// so here searchBoxActionTypes  specify  all the possible actions\n// that redux store can take place\nexport const searchChange = (\n  event: React.ChangeEvent<HTMLInputElement>\n): searchFieldActions => ({\n  type: SEARCHFIELD_CHANGE,\n  payload: event\n});\n","// Describing the shape of the searchField  slice of state\nexport interface ISearchValue {\n  inputValue: string;\n}\n\nexport const SEARCHFIELD_CHANGE = \" SEARCHFIELD_CHANGE\";\n// so we are exporting each actions in typescript format\ninterface searchFieldChangeAction {\n  type: typeof SEARCHFIELD_CHANGE;\n  payload: React.ChangeEvent<HTMLInputElement>;\n}\n\nexport type searchFieldActions = searchFieldChangeAction;\n","import React from \"react\";\nimport \"./SearchField.scss\";\nimport { searchChange } from \"../../Redux/SearchField/SearchField.actions\";\nimport { searchFieldActions } from \"../../Redux/SearchField/SearchField.types\";\nimport { connect } from \"react-redux\";\nimport { bindActionCreators } from \"redux\";\nimport { ThunkDispatch } from \"redux-thunk\";\n\ninterface SearchFieldProps {}\ntype Props = SearchFieldProps & LinkMapDispatchProps;\n\nconst SearchField: React.FC<Props> = ({ searchChange }) => {\n  return (\n    <React.Fragment>\n      <input\n        className=\"input-field\"\n        type=\"text\"\n        placeholder=\"Search Kittens\"\n        onChange={searchChange}\n      />\n    </React.Fragment>\n  );\n};\n// here we are specifying the return type of LinkMapDispatchProps\ninterface LinkMapDispatchProps {\n  searchChange: (event: React.ChangeEvent<HTMLInputElement>) => void;\n}\n\nconst mapDispatchToProps = (\n  dispatch: ThunkDispatch<any, any, searchFieldActions>\n):LinkMapDispatchProps => ({\n  // bindActionCreators is when you want to pass some action creators\n  // down to a component that isn't aware of Redux, and you don't want\n  //to pass dispatch or the Redux store to it.\n  searchChange: bindActionCreators(searchChange, dispatch)\n});\nexport default connect(null, mapDispatchToProps)(SearchField);\n","import React from \"react\";\nimport \"./Kittens.scss\";\nimport { IKittens } from \"../../Redux/Kittens/Kittens.types\";\n\n// here we are going to specify the type of the paramters \n// and the return type ,so here we are returning jsx element\nconst Kittens: React.FC<IKittens> = ({\n  name,\n  id,\n  email,\n  phone,\n  website\n}): JSX.Element => {\n  return (\n    <div className=\"kittens\">\n      <img\n        src={`https://robohash.org/${id}?set=set4&size=200x200&bgset=bg2`}\n        alt=\"kittens\"\n      />\n      <div>\n        <h3>Name:{name}</h3>\n        <h5>Email:{email}</h5>\n        <p>Website:{website}</p>\n        <p>Phone:{phone}</p>\n      </div>\n    </div>\n  );\n};\n\nexport default Kittens;\n","import React from \"react\";\nimport Kittens from \"../Kittens/Kittens\";\nimport \"./KittensList.scss\";\nimport { connect } from \"react-redux\";\nimport { IKittens } from \"../../Redux/Kittens/Kittens.types\";\nimport { AppState } from \"../../Redux/store\";\n\ninterface KittensListProps {}\n//here we are doing aggregation of all the props  types.\ntype Props = KittensListProps & LinkStateProps;\n\nconst KittensList: React.FC<Props> = ({ kittensArray, inputValue }) => {\n  kittensArray = kittensArray.filter(kitten => {\n    return kitten.name.toLowerCase().includes(inputValue.toLocaleLowerCase());\n  });\n\n  return (\n    <div className=\"kittens-list\">\n      {kittensArray.map(kitten => (\n        <Kittens\n          key={kitten.id}\n          id={kitten.id}\n          name={kitten.name}\n          phone={kitten.phone}\n          email={kitten.email}\n          website={kitten.website}\n        />\n      ))}\n    </div>\n  );\n};\n\n// here we need to specify the return type of  mapStateToProps.\ninterface LinkStateProps {\n  kittensArray: Array<IKittens>;\n  inputValue: string;\n}\n\n// here we are going to specify the  type for parameter state & return\n// type of mapStateToProps.\nconst mapStateToProps = (state: AppState): LinkStateProps => ({\n  kittensArray: state.kittensList.kittensArray,\n  inputValue: state.searchInput.inputValue\n});\nexport default connect(mapStateToProps)(KittensList);\n","import {\n  REQUEST_KITTENS_PENDING,\n  REQUEST_KITTENS_SUCCESS,\n  REQUEST_KITTENS_FAILED,\n  IKittens,\n  KittensActionTypes\n} from \"./Kittens.types\";\nimport { Dispatch } from \"redux\";\nimport { AppState } from \"../store\";\n\n// here we are goint specify one thing i.e return action type because\n//the requestKittensPending is not taking any paramter\nexport const requestKittensPending = (): KittensActionTypes => ({\n  type: REQUEST_KITTENS_PENDING\n});\n\n//now here we are going to specify the type of the parameter & the return action type\n// here the type of data is typeof Arrayobject & return action is typeof REQUEST_KITTENS_SUCCESS\nexport const requestKittensSuccess = (\n  data: Array<IKittens>\n): KittensActionTypes => ({\n  type: REQUEST_KITTENS_SUCCESS,\n  payload: data\n});\n\nexport const requestKittensFailed = (error: string): KittensActionTypes => ({\n  type: REQUEST_KITTENS_FAILED,\n  payload: error\n});\n\n// inorder to hook the dispatch to typescript in thunk we can use Dispatch\n// types that comes from redux\n// Dispatch is going to take a parameter i.e our KittensActiontypes\n// which defines all the actions  that can take place in the redux store\n\n// Redux will passes two arguments to thunk functions, dispatch & getState\n//dispatch, so that they can dispatch new actions if they need to.\n// getState,they can access the current state, that represent the state\n// of redux store\nexport const requestKittens = () => (\n  dispatch: Dispatch<KittensActionTypes>,\n  getState: () => AppState\n) => {\n  dispatch(requestKittensPending());\n  fetch(\"https://jsonplaceholder.typicode.com/users\")\n    .then(response => response.json())\n    .then(data => dispatch(requestKittensSuccess(data)))\n    .catch(error => dispatch(requestKittensFailed(error)));\n};\n","// Describing the shape of the kittens  slice of state\nexport interface IKittens {\n  id: number;\n  name: string;\n  email: string;\n  website: string;\n  phone: number;\n}\n\nexport interface IKittensArray {\n  kittensArray: Array<IKittens>;\n  isPending: boolean;\n  error: string;\n}\n\nexport const REQUEST_KITTENS_PENDING = \"REQUEST_KITTENS_PENDING \";\nexport const REQUEST_KITTENS_SUCCESS = \"REQUEST_KITTENS_SUCCESS \";\nexport const REQUEST_KITTENS_FAILED = \"REQUEST_KITTENS_FAILED \";\n\n// so we are exporting each actions in typescript format\n\nexport interface kittensPendingAction {\n  type: typeof REQUEST_KITTENS_PENDING;\n}\n\nexport interface kittensSuccessAction {\n  type: typeof REQUEST_KITTENS_SUCCESS;\n  payload: Array<IKittens>;\n}\n\nexport interface kittensFailedAction {\n  type: typeof REQUEST_KITTENS_FAILED;\n  payload: string;\n}\n\n// here we making the aggregation all these typescript actions\n// for that I am using the union operator or OR  operator.\n\nexport type KittensActionTypes =\n  | kittensPendingAction\n  | kittensSuccessAction\n  | kittensFailedAction;\n","import React from \"react\";\nimport \"./App.scss\";\nimport SearchField from \"../Components/SearchField/SearchField\";\nimport KittensList from \"../Components/KittensList/KittensList\";\nimport { connect } from \"react-redux\";\nimport { requestKittens } from \"../Redux/Kittens/Kittens.actions\";\nimport { KittensActionTypes } from \"../Redux/Kittens/Kittens.types\";\nimport { bindActionCreators } from \"redux\";\nimport { ThunkDispatch } from \"redux-thunk\";\n\ninterface IAppProps {}\ninterface IAppState {}\n\n// here we are doing aggregation of all the props  types.\ntype Props = IAppProps & LinkDispatchToProps;\n\nclass App extends React.Component<Props, IAppState> {\n  componentDidMount(): void {\n    this.props.requestKittens();\n  }\n  render() {\n    return (\n      <div className=\"App\">\n        <h1>Beautiful Kittens</h1>\n        <SearchField />\n        <KittensList />\n      </div>\n    );\n  }\n}\n\n// here we need to specify the return type of  mapDispatchToProps.\ninterface LinkDispatchToProps {\n  // here requesMonsters is a funtion that  not taking paramter &\n  // it returns void, thats what bascially dispatch returns.\n  requestKittens: () => void;\n}\nconst mapDispatchToProps = (\n  // normally we are using dispatch type, but here we are using thunk\n  // so we are using ThunkDispatch.\n  dispatch: ThunkDispatch<any, any, KittensActionTypes>\n): LinkDispatchToProps => ({\n  //bindActionCreators is when you want to pass some action creators\n  // down to a component that isn't aware of Redux, and you don't want\n  //to pass dispatch or the Redux store to it.\n  requestKittens: bindActionCreators(requestKittens, dispatch)\n});\nexport default connect(null, mapDispatchToProps)(App);\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import {\n  REQUEST_KITTENS_PENDING,\n  REQUEST_KITTENS_SUCCESS,\n  REQUEST_KITTENS_FAILED,\n  IKittensArray,\n  KittensActionTypes\n} from \"./Kittens.types\";\n//the first thing we need to do specify the type of default state or initial state\n// for that you have to make sure to import  the types from kittensActionTypes\nconst initialState: IKittensArray = {\n  kittensArray: [],\n  isPending: false,\n  error: \"\"\n};\n\n// now here we are going to specify the types of the parematers &\n// types of the return type\nexport const requestKittensReducer = (\n  state = initialState,\n  action: KittensActionTypes\n): IKittensArray => {\n  switch (action.type) {\n    case REQUEST_KITTENS_PENDING:\n      return {\n        ...state,\n        isPending: true\n      };\n    case REQUEST_KITTENS_SUCCESS:\n      return {\n        ...state,\n        isPending: false,\n        kittensArray: action.payload\n      };\n\n    case REQUEST_KITTENS_FAILED:\n      return {\n        ...state,\n        isPending: false,\n        error: action.payload\n      };\n    default:\n      return state;\n  }\n};\n","import {\n  SEARCHFIELD_CHANGE,\n  ISearchValue,\n  searchFieldActions\n} from \"./SearchField.types\";\n\n// the first thing to  do  specify type for the initial state or the default state.\n// you have to make sure to import the types from the searchBox types.\nconst initialState: ISearchValue = {\n  inputValue: \"\"\n};\n\n// now we are going to specify the types for  parameters & return reducer types.\n//Here we need to do two things , the first thing is to do a type\n// for the action for that we need to import searchFieldActionsTypes.\n// seconde thing is to do specify type for the return type as well\n// in here we return the searchField  so here we need to say ISearchValue.\nexport const searchChangeReducer = (\n  state = initialState,\n  action: searchFieldActions\n): ISearchValue => {\n  switch (action.type) {\n    case SEARCHFIELD_CHANGE:\n      return {\n        ...state,\n        inputValue: action.payload.target.value\n      };\n    default:\n      return state;\n  }\n};\n","import { requestKittensReducer } from \"../Redux/Kittens/Kitten.reducers\";\nimport { searchChangeReducer } from \"../Redux/SearchField/SearchField.reducer\";\nimport { combineReducers } from \"redux\";\n\nexport default combineReducers({\n  kittensList: requestKittensReducer,\n  searchInput: searchChangeReducer\n});\n","import rootReducer from \"./rootReducer\";\nimport { createStore, applyMiddleware } from \"redux\";\nimport logger from \"redux-logger\";\nimport thunk, { ThunkMiddleware } from \"redux-thunk\";\nimport { KittensActionTypes } from \"./Kittens/Kittens.types\";\n\n// here we are grabbing all the state types from different reducers.\nexport type AppState = ReturnType<typeof rootReducer>;\n// in store little  bit of alteration is needed  to thunk piece so instead\n// of just specifying thunk here, we are going to do thunk as thunkMiddleware\n//here type as means new type assertion. thunkMiddleware comes from\n// redux-thunk library, this is going to take two parameters , one is the\n// AppState and the other one is the App actions in our case it is\n// KittensActionTypes\n\nconst middlewares = [thunk as ThunkMiddleware<AppState, KittensActionTypes>];\nif (process.env.NODE_ENV === \"development\") {\n  middlewares.push(logger);\n}\n\nconst store = createStore(rootReducer, applyMiddleware(...middlewares));\nexport default store;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.scss\";\nimport App from \"./Containers/App\";\nimport * as serviceWorker from \"./serviceWorker\";\nimport store from \"./Redux/store\";\nimport { Provider } from \"react-redux\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <Provider store={store}>\n      <App />\n    </Provider>\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}